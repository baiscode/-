1. 箭头函数与普通函数的区别

   * 箭头函数是匿名函数，不能用做构造函数，不能使用new关键字

   ```javascript
   const foo = () => {
     console.log('foo')
   }
   new foo();  // Uncaught TypeError: foo is not a constructor;
   ```

   * 箭头函数不能绑定arguments，取而代之的使用rest参数

   ```javascript
   const foo = () => {
     console.log(arguments);
   }
   foo(1, 2, 3);  // Uncaught ReferenceError: arguments is not defined;
   
   // 正确使用
   const bar = (...c) => {
     console.log(c)
   }
   bar(1, 2, 3) //[1, 2, 3]
   ```

   * 箭头函数没有原型属性

   ```javascript
   const foo = () => {}
   console.log(foo.prototype)  // undefined
   ```

   * 箭头函数不能绑定this，而是补货其在上下文中的this值，作为自己的this值

   ```javascript
   const obj = {
     a: () => {
       console.log(this)  // window
     },
     b: function() {
       console.log(this) // obj
     }
   }
   ```

   * 箭头函数的this绑定后不能再修改

   ```javascript
   var a = 'c';
   const foo = {
     a: 'a',
     b: function() {
       console.log(this.a)
     }
   }
   
   const bar = {
     a: 'a',
     b: () => {
       console.log(this.a)
     }
   }
   
   const baz = {
     a: 'c'
   }
   
   foo.b.call(baz); // 'c'
   bar.b.call(baz); // 'a'
   ```


2. Ajax原理

   ajax原理就是通过 XMLHttpRequest 对象向服务器发送异步请求，从服务器获取数据，然后用js刷新页面。

   XMLHttpRequest 对象属性

   onreadystatechange   每次状态改变所触发事件的事件处理程序

   responseText               从服务器返回数据的字符串形式  

   responseXml                从服务器返回的DOM兼容的文档数据对象

   status                             从服务器返回的请求状态码

   statusText                     伴随状态码的字符串信息

   readyState                     对象状态值

   1 - 未初始化  对象已建立，但是尚未初始化（尚未调用 open 方法）

   2 - 初始化    对象已建立，尚未调用 send 方法

   3 - 发送数据  send方法已调用，并且头部和状态已经可以获得

   4 - 数据传输中 响应体部分正在被接收

   5 - 完成   请求操作已经完成，此时可以通过 responseText 和 responseXml 获取完整数据

   通过XMLHttpRequest创建请求

   ```javascript
   function request(method = 'get', url, async = true, callback, data) {
     callback = callback || function() {}
     let server = new XMLHttpRequest()
     server.open(method, url, async)
     server.send(data)server.timeout = 5000
     server.ontimeout = function() {console.log('请求超时！')}
     server.onreadystatechange = function(res) {
       if(res.readyState === 4 && res.status === 200) {
         callback(res)
       }
     }
   }
   
   post传参方式：
   server.send('name=jack&age=21')
   ```

3. class关键字和构造函数的区别

   * class声明会提升，但不会初始化赋值

   ```javascript
   const bar = new Bar(); // it's ok
   function Bar() {
     this.bar = 42;
   }
   
   const foo = new Foo(); // ReferenceError: Foo is not defined
   class Foo {
     constructor() {
       this.foo = 42;
     }
   }
   ```

   * class的所有方法都是不可枚举的

   ```javascript
   // 引用一个未声明的变量
   function Bar() {
     this.bar = 42;
   }
   Bar.answer = function() {
     return 42;
   }
   Bar.prototype.print = function() {
     console.log(this.bar);
   }
   const barKeys = Object.keys(Bar); // ['answer']
   const barProtoKeys = Object.keys(Bar.prototype); // ['print']
   
   class Foo {
     constructor() {
       this.foo = 42;
     }
     static answer() {
       return 42;
     }
     print() {
       console.log(this.foo)
     }
   }
   const fooKeys = Object.keys(Foo); // []
   const fooProtoKeys = Object.kyes(Foo.prototype); // []
   ```

   * class的所有方法都没有原型对象prototype，也没有[[constructor]]，不能使用new关键子调用

   ```javascript
   function Bar() {
     this.bar = 42;
   }
   Bar.prototype.print = function() {
     console.log(this.bar);
   }
   const bar = new Bar();
   const barPrint = new bar().print(); // it's ok
   
   class Foo {
     constructor() {
       this.foo = 42;
     }
     print() {
       console.log(this.foo);
     }
   }
   const foo = new Foo();
   const fooPrint = new foo().print(); // TypeError: foo.print is not a constructor
   ```

   * 必须使用new关键字调用class

   ```javascript
   function Bar() {
     this.bar = 42;
   }
   const bar = Bar(); // it's ok
   
   class Foo {
     constructor() {
       this.foo = 42;
     }
   }
   const foo = Foo(); // TypeError: class constructor Foo cannot be invoke without 'new'
   ```

4. == 和 === 和 Object.is()

   * ==  和 ===

     ![==和==](/Users/a/Desktop/projects/knowledge/images/1.png)

   * === 和 Object.is()

     ```javascript
     -0 === +0  // true
     NaN === NaN  // false
     
     Object.is(-0, +0)   // false
     Object.is(NaN, NaN)  // true
     function is(x, y) {
       if(x === y) {
         // x !== 0 判断 +0 和 -0
         // 1 / x === 1 / y 判断 x===0, y === 0
         return x !== 0 || y !== 0 || 1 / x === 1 / y;
       }else {
         // 判断x、y是否是NaN
         return x !== x && y !== y;
       }
     }
     ```

5. 原型链

   ![原型链](/Users/a/Desktop/projects/knowledge/images/2.png)

6. 